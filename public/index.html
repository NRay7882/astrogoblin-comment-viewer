<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astrogoblin Comment Shop Picker (local testing)</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 800px; 
            margin: 50px auto; 
            padding: 20px;
            background: #f5f5f5;
        }
        .container { 
            background: white; 
            padding: 30px; 
            border-radius: 10px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        button { 
            background: #ff6b35; 
            color: white; 
            border: none; 
            padding: 12px 24px; 
            border-radius: 5px; 
            cursor: pointer; 
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover { background: #e55a2d; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input[type="url"] { 
            width: 100%; 
            padding: 12px; 
            border: 2px solid #ddd; 
            border-radius: 5px; 
            font-size: 16px;
            margin: 10px 0;
        }
        .status { 
            padding: 15px; 
            margin: 15px 0; 
            border-radius: 5px; 
            display: none;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { 
			background: linear-gradient(135deg, #f8d7da, #f5c6cb); 
			color: #721c24; 
			border: 1px solid #f5c6cb;
			font-weight: 500;
			line-height: 1.4;
		}
        .status.loading { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .comment { 
            background: #f8f9fa; 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 5px; 
            border-left: 4px solid #ff6b35;
        }
        .comment-meta { 
            font-size: 0.9em; 
            color: #666; 
            margin-top: 10px;
        }
		.comment-author {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .profile-image {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #ddd;
        }
        .results { display: none; }
        
        /* Star Map Styles */
        #star-map-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 1s ease, visibility 1s ease;
        }
        
        #star-map-container.active {
            opacity: 1;
            visibility: visible;
        }
        
        .room-environment {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: 
				linear-gradient(to bottom, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.6)),
				url('jediroom.jpg');
			background-size: cover;
			background-position: center;
			background-blend-mode: multiply;
			z-index: 1;
		}
        
        .room-environment::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(30, 40, 60, 0.3) 0%, transparent 25%),
                radial-gradient(circle at 80% 20%, rgba(40, 50, 70, 0.2) 0%, transparent 30%),
                radial-gradient(circle at 60% 90%, rgba(25, 35, 50, 0.4) 0%, transparent 20%);
            z-index: 1;
        }
        
        .room-environment::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.6) 30%, transparent 100%);
            z-index: 1;
        }
        
        .podium {
			position: absolute;
			bottom: 10%;
			left: 50%;
			transform: translateX(-50%);
			width: 200px;
			height: 80px;
			background-image: url('projector.png');
			background-size: contain;
			background-repeat: no-repeat;
			background-position: center;
			z-index: 10;
			filter: brightness(0.8) contrast(1.2);
		}

		.podium::before,
		.podium::after {
			display: none;
		}

		.podium::before {
			content: '';
			position: absolute;
			top: 12px;
			left: 12px;
			right: 12px;
			bottom: 12px;
			background: 
				linear-gradient(45deg, transparent 30%, rgba(70, 130, 180, 0.15) 50%, transparent 70%),
				radial-gradient(circle at 30% 30%, rgba(135, 206, 235, 0.25) 0%, transparent 60%);
			border-radius: 75px 75px 8px 8px;
			border: 1px solid rgba(70, 130, 180, 0.4);
		}

		.podium::after {
			content: '';
			position: absolute;
			top: -8px;
			left: 50%;
			transform: translateX(-50%);
			width: 110px;
			height: 16px;
			background: 
				linear-gradient(to right, transparent, rgba(70, 130, 180, 0.5), transparent),
				radial-gradient(ellipse, rgba(135, 206, 235, 0.4) 0%, transparent 70%);
			border-radius: 55px;
			filter: blur(1px);
		}

		.orb {
			position: absolute;
			top: -32px;
			left: 50%;
			transform: translateX(-50%);
			width: 36px;
			height: 36px;
			background: 
				radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.9) 0%, rgba(135, 206, 235, 0.95) 25%, rgba(70, 130, 180, 1) 55%, rgba(25, 25, 112, 1) 100%);
			border-radius: 50%;
			box-shadow: 
				0 0 30px rgba(70, 130, 180, 0.9),
				inset 0 3px 10px rgba(255, 255, 255, 0.4),
				inset 0 -3px 8px rgba(0, 0, 0, 0.4);
			z-index: 11;
			opacity: 0.85;
			border: 2px solid rgba(70, 130, 180, 0.7);
			position: relative;
		}

		.orb::before {
			content: '';
			position: absolute;
			top: 6px;
			left: 8px;
			width: 10px;
			height: 6px;
			background: rgba(255, 255, 255, 0.7);
			border-radius: 50%;
			filter: blur(0.5px);
		}

		.orb::after {
			content: '';
			position: absolute;
			top: -6px;
			left: -6px;
			right: -6px;
			bottom: -6px;
			border: 1px solid rgba(70, 130, 180, 0.4);
			border-radius: 50%;
			animation: orb-ring-pulse 3s ease-in-out infinite;
		}
        
        .orb.glowing {
            animation: orb-activation 3s ease-in-out forwards;
        }
        
        @keyframes orb-activation {
            0% { 
                transform: translateX(-50%) scale(1);
                box-shadow: 0 0 15px rgba(70, 130, 180, 0.6);
                opacity: 0.7;
            }
            30% { 
                transform: translateX(-50%) scale(1.2);
                box-shadow: 0 0 40px rgba(70, 130, 180, 0.9);
                opacity: 1;
            }
            60% { 
                transform: translateX(-50%) scale(1.5);
                box-shadow: 0 0 80px rgba(255, 255, 255, 1);
                opacity: 1;
            }
            80% { 
                transform: translateX(-50%) scale(2);
                box-shadow: 0 0 150px rgba(255, 255, 255, 1);
                opacity: 0.8;
            }
            100% { 
                transform: translateX(-50%) scale(0.8);
                box-shadow: 0 0 25px rgba(70, 130, 180, 0.8);
                opacity: 0.9;
            }
        }

		@keyframes orb-ring-pulse {
			0%, 100% {
				opacity: 0.3;
				transform: scale(1);
			}
			50% {
				opacity: 0.8;
				transform: scale(1.1);
			}
		}
		
		.projector-beam {
			position: absolute;
			top: -40px;
			left: 50%;
			transform: translateX(-50%);
			width: 60px;
			height: 80px;
			background: 
				radial-gradient(ellipse at center bottom, rgba(135, 206, 235, 0.8) 0%, rgba(70, 130, 180, 0.4) 30%, transparent 70%),
				linear-gradient(to top, rgba(135, 206, 235, 0.6) 0%, rgba(70, 130, 180, 0.3) 50%, transparent 100%);
			border-radius: 50%;
			z-index: 9;
			opacity: 0.7;
			filter: blur(2px);
			animation: beam-pulse 3s ease-in-out infinite;
		}

		@keyframes beam-pulse {
			0%, 100% {
				opacity: 0.5;
				transform: translateX(-50%) scale(1);
			}
			50% {
				opacity: 0.8;
				transform: translateX(-50%) scale(1.1);
			}
		}
		
		@keyframes beam-activation {
			0% { 
				opacity: 0;
				transform: translateX(-50%) scale(0.5);
			}
			50% { 
				opacity: 1;
				transform: translateX(-50%) scale(1.3);
			}
			100% { 
				opacity: 0.7;
				transform: translateX(-50%) scale(1);
			}
		}

        #hologram-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
            pointer-events: auto;
            user-select: none;
        }
        
        .hologram-projection {
            position: absolute;
            bottom: 11%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 600px;
            background: 
                radial-gradient(ellipse at center bottom, rgba(135, 206, 235, 0.05) 0%, rgba(135, 206, 235, 0.02) 40%, transparent 70%);
            border-radius: 50%;
            z-index: 2;
            filter: blur(3px);
            animation: projection-pulse 4s ease-in-out infinite;
        }
        
        .hologram-grid {
            display: none;
        }
        
        @keyframes projection-pulse {
            0%, 100% { 
                opacity: 0.4; 
                transform: translateX(-50%) scale(1);
                filter: blur(3px);
            }
            50% { 
                opacity: 0.7; 
                transform: translateX(-50%) scale(1.02);
                filter: blur(2px);
            }
        }
        
        .flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(135,206,235,0.3) 40%, transparent 70%);
            opacity: 0;
            z-index: 8;
            pointer-events: none;
        }
        
        .flash-overlay.active {
            animation: flash-burst 0.8s ease-out forwards;
        }
        
        @keyframes flash-burst {
            0% { opacity: 0; transform: scale(0.1); }
            10% { opacity: 1; transform: scale(0.3); }
            30% { opacity: 0.8; transform: scale(1.5); }
            100% { opacity: 0; transform: scale(3); }
        }
        
        .close-star-map {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 15;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .close-star-map:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .star-map-info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 15;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .star-map-info h3 {
            margin: 0 0 10px 0;
            color: #87ceeb;
        }
        
        .star-map-info p {
            margin: 5px 0;
            font-size: 14px;
            opacity: 0.9;
        }
        
        .galaxy-tips {
			margin-top: 15px;
			padding-top: 10px;
			border-top: 1px solid rgba(135, 206, 235, 0.3);
			font-size: 12px;
			opacity: 0.8;
		}

		.galaxy-tips h4 {
			margin: 0 0 8px 0;
			font-size: 13px;
			color: #87ceeb;
		}

		.galaxy-tips h4:not(:first-child) {
			margin-top: 12px;
		}

		.galaxy-tips ul {
			margin: 0;
			padding-left: 0;
			list-style-type: none;
		}
		
		.galaxy-tips li {
			margin: 4px 0;
			display: flex;
			align-items: flex-start;
		}

		.galaxy-tips li:before {
			content: "✨";
			margin-right: 4px;
			width: 16px;
			text-align: left;
			flex-shrink: 0;
		}

		/* Special styling for star legend items */
		.galaxy-tips ul:last-child li:before {
			content: ""; /* Remove sparkle for star legend */
			margin-right: 0; /* Remove margin for sparkle space */
			width: 0; /* Remove width for sparkle space */
		}

		.galaxy-tips ul:last-child li {
			align-items: center;
			margin-left: 0; /* Ensure no extra left margin */
		}

		/* Specific styling for colored dot items (items 2-6 in Star Legend) */
		.galaxy-tips h4:nth-of-type(2) + ul li:nth-child(n+2) {
			padding-left: 0; /* Remove any extra padding */
			margin-left: 0; /* Align with other items */
		}

		/* Force proper spacing for galaxy tips */
		.galaxy-tips h4:nth-of-type(2) + ul li:nth-child(n+2) span {
			font-size: 16px;
			text-shadow: 0 0 3px currentColor;
			margin-right: 6px !important; /* Reduce spacing for better text alignment */
			width: 16px;
			text-align: center;
			flex-shrink: 0;
			position: relative;
			left: 0px;
			display: inline-block;
		}

		.galaxy-tips ul:last-child li span {
			font-size: 16px;
			text-shadow: 0 0 3px currentColor;
			margin-right: 12px; /* Increase spacing between dot and text */
			width: 16px;
			text-align: center;
			flex-shrink: 0;
			position: relative;
			left: 0px;
		}
		
		/* Remove sparkles from Star Legend items with colored dots (items 2-6) */
		.galaxy-tips h4:nth-of-type(2) + ul li:nth-child(n+2):before {
			content: "";
			margin-right: 0;
			width: 0;
		}
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 25;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        
        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .loading-text {
            color: #87ceeb;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .loading-bar-container {
            width: 400px;
            height: 20px;
            background: rgba(135, 206, 235, 0.2);
            border: 2px solid #87ceeb;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #87ceeb, #4682b4, #87ceeb);
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.3s ease;
            animation: loading-shimmer 2s ease-in-out infinite;
        }
        
        .loading-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }
        
        @keyframes loading-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .audio-controls {
            position: absolute;
            top: 20px;
            right: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 15;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .audio-controls:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .audio-controls.muted {
            background: rgba(255, 100, 100, 0.3);
            border-color: rgba(255, 100, 100, 0.5);
        }
        
        .audio-prompt {
            display: none !important;
        }
        
		.star-map-tooltip {
			position: absolute;
			background: rgba(0, 0, 0, 0.95);
			color: white;
			padding: 15px;
			border-radius: 10px;
			border: 2px solid #87ceeb;
			min-width: 200px;
			max-width: 450px;
			width: auto;
			z-index: 100;
			pointer-events: none; /* Start with no pointer events */
			opacity: 0;
			transition: opacity 0.2s ease;
			backdrop-filter: blur(15px);
			box-shadow: 0 0 30px rgba(135, 206, 235, 0.5);
		}

		.star-map-tooltip.visible {
			opacity: 1;
		}

		.star-map-tooltip.interactive {
			pointer-events: auto; /* Enable interactions when needed */
		}

		.tooltip-header {
			display: flex;
			align-items: center;
			margin-bottom: 10px;
			border-bottom: 1px solid rgba(135, 206, 235, 0.3);
			padding-bottom: 8px;
			white-space: nowrap;
		}

		.tooltip-avatar {
			width: 24px;
			height: 24px;
			border-radius: 50%;
			margin-right: 8px;
			border: 1px solid #87ceeb;
			flex-shrink: 0;
		}

		.tooltip-username {
			color: #87ceeb;
			font-weight: bold;
			font-size: 14px;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.tooltip-content {
			font-size: 13px;
			line-height: 1.5;
			margin-bottom: 10px;
			word-wrap: break-word;
			white-space: pre-wrap;
		}

		.tooltip-meta {
			font-size: 11px;
			opacity: 0.7;
			display: flex;
			flex-direction: column;
			gap: 4px;
			margin-bottom: 8px;
		}

		.tooltip-meta span {
			white-space: nowrap;
		}
		
		/* Save button styling */
		.tooltip-save-button {
			background: linear-gradient(135deg, #4CAF50, #45a049);
			color: white;
			border: none;
			padding: 6px 12px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 11px;
			font-weight: bold;
			transition: all 0.2s ease;
			margin-top: 5px;
			width: 100%;
			position: relative;
			overflow: hidden;
		}

		.tooltip-save-button:hover {
			background: linear-gradient(135deg, #45a049, #3d8b40);
			transform: translateY(-1px);
			box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
		}

		.tooltip-save-button.saved {
			background: linear-gradient(135deg, #FFD700, #FFA500);
			color: #000;
		}

		.tooltip-save-button.saved:hover {
			background: linear-gradient(135deg, #FFA500, #FF8C00);
		}
		
		.saved-star-glow {
			position: absolute;
			width: 100%;
			height: 100%;
			border-radius: 50%;
			background: radial-gradient(circle, rgba(255, 215, 0, 0.4) 0%, rgba(255, 215, 0, 0.1) 70%, transparent 100%);
			pointer-events: none;
			animation: saved-pulse 2s ease-in-out infinite;
		}

		@keyframes saved-pulse {
			0%, 100% { 
				opacity: 0.6; 
				transform: scale(1);
			}
			50% { 
				opacity: 0.9; 
				transform: scale(1.1);
			}
		}

    </style>
</head>
<body>
    <div class="container">
        <h1>Astrogoblin Comment Shop Picker</h1>
        <p>Note: This will ONLY display post details for creators of the post. Campaign subscribers cannot use this to view details for other creators, this is a limitation in the Patreon API.</p>
        
        <div id="auth-section">
            <h3 id="auth-status">🔐 Not Authenticated</h3>
            <button onclick="connectPatreon()">Connect to Patreon</button>
        </div>
        
        <div id="extract-section" style="display: none;">
            <h3>Fetch Post Comments</h3>
            <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                📝 <strong>Note:</strong> You can only fetch comments from posts you created on your own Patreon account.
            </p>
            <input type="url" id="postUrl" placeholder="https://www.patreon.com/posts/comment-shop-53-130475681" 
                   value="">
            <br>
            <button onclick="extractComments()">Find Comments</button>
        </div>
        
        <div id="status" class="status"></div>
        
        <div id="results" class="results">
            <h3>Results</h3>
            <div id="results-content"></div>
        </div>
    </div>

    <!-- Star Map Container -->
    <div id="star-map-container">
        <div class="room-environment"></div>
        <div class="hologram-projection"></div>
        <div class="hologram-grid"></div>
        <div class="flash-overlay" id="flash-overlay"></div>
        
        <div class="star-map-info" id="star-map-info">
			<h3>The Comment Galaxy</h3>
			<p id="post-title">Loading...</p>
			<p id="comment-count">0 comments found</p>
			<p id="total-likes">0 total likes</p>
			<button class="audio-controls" id="audio-toggle-info" onclick="toggleAudio()" title="Toggle Audio" style="margin-top: 10px; position: relative; top: 0; right: 0; width: 30px; height: 30px; font-size: 14px;">🔊</button>
			
			<div class="galaxy-tips">
				<h4>Navigation Tips:</h4>
				<ul>
					<li>Use mouse to rotate the map</li>
					<li>Use scroll wheel to zoom in & out</li>
					<li>Hover over stars to see comments</li>
					<li>Press Escape to close galaxy</li>
				</ul>
				
				<h4>Star Legend:</h4>
				<ul>
					<li>Comment stars with more likes appear larger</li>
					<li><span style="color: #E6F3FF;">●</span> All comment stars appear in white</li>
					<li><span style="color: #808080;">●</span> Read comment stars turn gray & shrink in size</li>
					<li><span style="color: #FFD700;">●</span> Saved stars turn golden & stay highlighted</li>
				</ul>

				<h4>Interaction Tips:</h4>
				<ul style="list-style-type: none; padding-left: 0;">
					<li>Save Comment highlights the star</li>
					<li>Saved comments aren't preserved from previous sessions</li>
				</ul>
			</div>
		</div>
        
        <button class="audio-controls" id="audio-toggle" onclick="toggleAudio()" title="Toggle Audio">🔊</button>
        <button class="close-star-map" onclick="closeStarMap()">Close Galaxy</button>
        
        <div class="podium">
			<div class="projector-beam"></div>
		</div>
        <canvas id="hologram-canvas"></canvas>
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="loading-overlay">
            <div class="loading-text">Generating Comment Galaxy...</div>
            <div class="loading-bar-container">
                <div class="loading-percentage" id="loading-percentage">0%</div>
                <div class="loading-bar" id="loading-bar"></div>
            </div>
        </div>
        
        <!-- Audio Prompt -->
        <div id="audio-prompt" class="audio-prompt">
            <h3 style="margin-top: 0; color: #87ceeb;">🎵 Immersive Audio Experience</h3>
            <p>Click to enable background music for the full galaxy experience!</p>
            <button onclick="enableAudio()" style="background: #87ceeb; color: #000; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 10px;">Enable Audio</button>
            <button onclick="skipAudio()" style="background: transparent; color: white; border: 1px solid #87ceeb; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 10px;">Skip</button>
        </div>
        
        <!-- Tooltip for star hover -->
		<div id="star-tooltip" class="star-map-tooltip">
			<div class="tooltip-header">
				<img id="tooltip-avatar" class="tooltip-avatar" src="" alt="" style="display: none;">
				<span id="tooltip-username" class="tooltip-username"></span>
			</div>
			<div id="tooltip-content" class="tooltip-content"></div>
			<div class="tooltip-meta">
				<span id="tooltip-likes"></span>
				<span id="tooltip-date"></span>
			</div>
		</div>

    </div>

    <!-- Audio element for background music -->
    <audio id="galaxy-audio" loop preload="auto">
        <source src="galaxy-music.mp3" type="audio/mpeg">
        <source src="galaxy-music.wav" type="audio/wav">
        Your browser does not support the audio element.
    </audio>

    <!-- Audio element for sound effects -->
    <audio id="sound-effects" preload="auto">
        <!-- Source will be set dynamically -->
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let extractedData = null;
        let isAuthenticated = false;
        let starMapHologram = null;
        let galaxyAudio = null;
        let soundEffectsAudio = null;
        let isAudioMuted = false;
        let audioContext = null;

        // Sound effect files
        const soundEffects = [
            'gravity.mp3',
            'aughttobe.mp3', 
            'gather.mp3',
            'embarassing.mp3'
        ];

        // Fixed Star Map Hologram Class
        class StarMapHologram {
            constructor(commentData) {
				this.scene = null;
				this.camera = null;
				this.renderer = null;
				this.starSystems = [];
				this.connections = [];
				this.animationFrame = null;
				this.isAnimating = false;
				this.commentData = commentData;
				this.raycaster = new THREE.Raycaster();
				this.mouse = new THREE.Vector2();
				this.hoveredStar = null;
				this.tooltip = null; // Will be set when needed
				this.canvas = null;
				
				// Simplified state management
				this.isHoveringCanvas = false;
				this.isHoveringTooltip = false;
				this.isHoveringButton = false;
				this.currentHoveredComment = null;
				this.showTooltipTimeout = null;
				this.hideTooltipTimeout = null;
				
				// Mouse control
				this.mouseDown = false;
				this.mouseX = 0;
				this.mouseY = 0;
				this.rotationX = 0;
				this.rotationY = 0;
				this.autoRotate = true;
				this.controlsEnabled = false;
				
				// Zoom control
				this.zoomLevel = 1.0;
				this.minZoom = 0.3;
				this.maxZoom = 3.0;
				
				// Loading progress
				this.loadingProgress = 0;
				this.isLoading = true;
				
				// Read state tracking
				this.readTimer = null;
				
				// Save state tracking
				this.savedStars = new Set();
				
				console.log('StarMapHologram: Starting initialization');
				this.init();
				this.setupControls();
			}
            
            init() {
                console.log('StarMapHologram: Initializing Three.js scene');
                
                this.canvas = document.getElementById('hologram-canvas');
				const canvas = this.canvas;
                
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    alpha: true,
                    antialias: true 
                });
                
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                
                this.camera.position.set(0, 0, 8);
                this.camera.lookAt(0, 0, 0);
                
                this.createStarMapFromComments();
                this.createStarConnections();
                
                // Add atmospheric lighting and fog
                const ambientLight = new THREE.AmbientLight(0x4682b4, 0.1);
                this.scene.add(ambientLight);
                
                // Add subtle fog for depth
                this.scene.fog = new THREE.Fog(0x000000, 5, 25);
                
                // Add atmospheric particles
                this.createAtmosphericParticles();
                
                // Add background stars/galaxies
                this.createBackgroundStars();
                
                console.log('StarMapHologram: Scene initialized');
            }
            
            // Controls with cursor management
			setupControls() {
				console.log('StarMapHologram: Setting up controls');
				
				this.canvas = document.getElementById('hologram-canvas');
				
				// Mouse move handler with hover detection
				this.canvas.addEventListener('mousemove', (e) => {
					if (!this.controlsEnabled) return;
					
					const rect = this.canvas.getBoundingClientRect();
					this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
					this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
					
					// Handle dragging
					if (this.mouseDown) {
						const deltaX = e.clientX - this.mouseX;
						const deltaY = e.clientY - this.mouseY;
						
						this.rotationY += deltaX * 0.01;
						this.rotationX += deltaY * 0.01;
						this.rotationX = Math.max(-1, Math.min(1, this.rotationX));
						
						this.mouseX = e.clientX;
						this.mouseY = e.clientY;
						
						this.autoRotate = false;
					} else {
						// Check for star hover
						this.checkStarHover();
					}
				});
				
				// Mouse down with proper cursor management
				this.canvas.addEventListener('mousedown', (e) => {
					if (!this.controlsEnabled) return;
					
					this.mouseDown = true;
					this.mouseX = e.clientX;
					this.mouseY = e.clientY;
					this.autoRotate = false;
					this.setCursor('grabbing');
					this.hideTooltipImmediate();
				});
				
				// Mouse up with cursor restoration
				this.canvas.addEventListener('mouseup', () => {
					if (!this.mouseDown) return;
					this.mouseDown = false;
					this.setCursor('grab');
					
					// Force state recovery
					setTimeout(() => {
						if (!this.mouseDown && !this.isHoveringTooltip && !this.currentHoveredComment) {
							this.autoRotate = true;
							console.log('🔄 Auto-rotation resumed after mouse up');
						}
					}, 100);
				});
				
				// Mouse enter/leave for canvas
				this.canvas.addEventListener('mouseenter', () => {
					this.isHoveringCanvas = true;
					if (this.controlsEnabled && !this.mouseDown) {
						this.setCursor('grab');
					}
				});
				
				this.canvas.addEventListener('mouseleave', () => {
					this.isHoveringCanvas = false;
					this.mouseDown = false;
					this.setCursor('default');
					this.hideTooltipWithDelay();
					
					setTimeout(() => {
						if (!this.isHoveringTooltip) {
							this.autoRotate = true;
						}
					}, 500);
				});
				
				// Global mouse up handler
				document.addEventListener('mouseup', () => {
					if (this.mouseDown) {
						this.mouseDown = false;
						if (this.isHoveringCanvas) {
							this.setCursor('grab');
						}
					}
				});
				
				// Mouse wheel zoom
				this.canvas.addEventListener('wheel', (e) => {
					if (!this.controlsEnabled || this.isLoading) return;
					
					e.preventDefault();
					
					const zoomSpeed = 0.1;
					const delta = e.deltaY > 0 ? 1 : -1;
					const newZoom = this.zoomLevel + (delta * zoomSpeed);
					
					this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));
					
					const baseDistance = 8;
					const newDistance = baseDistance / this.zoomLevel;
					
					const direction = new THREE.Vector3();
					this.camera.getWorldDirection(direction);
					direction.multiplyScalar(-newDistance);
					
					this.camera.position.copy(direction);
					this.camera.lookAt(0, 0, 0);
				});
				
				// Tooltip interaction setup
				this.setupTooltipInteraction();
			}

			// Centralized cursor management
			setCursor(cursorType) {
				if (this.canvas) {
					this.canvas.style.cursor = cursorType;
				}
			}
            
            showLoadingOverlay() {
                const overlay = document.getElementById('loading-overlay');
                overlay.classList.add('active');
            }
            
            hideLoadingOverlay() {
                const overlay = document.getElementById('loading-overlay');
                overlay.classList.remove('active');
            }
            
            updateLoadingProgress(percentage, message) {
                const bar = document.getElementById('loading-bar');
                const percentageText = document.getElementById('loading-percentage');
                const loadingText = document.querySelector('.loading-text');
                
                if (bar) bar.style.width = `${percentage}%`;
                if (percentageText) percentageText.textContent = `${percentage}%`;
                if (loadingText) loadingText.textContent = message;
                
                this.loadingProgress = percentage;
            }
            
            playRandomSoundEffect() {
                if (isAudioMuted) {
                    console.log('Audio is muted, skipping sound effect');
                    return;
                }
                
                if (!soundEffectsAudio) {
                    soundEffectsAudio = document.getElementById('sound-effects');
                }
                
                if (soundEffectsAudio) {
                    const randomIndex = Math.floor(Math.random() * soundEffects.length);
                    const selectedSound = soundEffects[randomIndex];
                    
                    console.log('Playing random sound effect:', selectedSound);
                    
                    soundEffectsAudio.src = selectedSound;
                    soundEffectsAudio.volume = 0.5;
                    
                    const playPromise = soundEffectsAudio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('Sound effect played successfully:', selectedSound);
                        }).catch(error => {
                            console.log('Sound effect play failed:', error);
                        });
                    }
                }
            }
            
            // Hover detection with proper delays
			checkStarHover() {
				if (this.isLoading || this.mouseDown) return;
				
				this.raycaster.setFromCamera(this.mouse, this.camera);
				
				const starMeshes = [];
				this.starSystems.forEach(starGroup => {
					// Include both the main star mesh (index 0) and glow mesh (index 1)
					if (starGroup.children[0]) {
						starMeshes.push(starGroup.children[0]); // Main star
					}
					if (starGroup.children[1]) {
						starMeshes.push(starGroup.children[1]); // Glow
					}
					// Also include any saved glow effects
					starGroup.children.forEach(child => {
						if (child.userData.isSavedGlow) {
							starMeshes.push(child);
						}
					});
				});
				
				const intersects = this.raycaster.intersectObjects(starMeshes);
				
				if (intersects.length > 0) {
					const intersectedMesh = intersects[0].object;
					const starGroup = intersectedMesh.parent;
					const comment = starGroup.userData.config?.comment;
					
					if (comment && comment !== this.currentHoveredComment) {
						console.log('🌟 Hovering new star/glow:', comment.username);
						this.currentHoveredComment = comment;
						this.hoveredStar = starGroup;
						this.autoRotate = false;
						this.showTooltipWithDelay(comment, intersects[0].point);
					} else if (comment && comment === this.currentHoveredComment) {
						// If still hovering on the same star - ensure read timer is running if tooltip is visible
						const tooltip = document.getElementById('star-tooltip');
						const tooltipVisible = tooltip && tooltip.classList.contains('visible');
						if (tooltipVisible && !this.readTimer && !starGroup.userData.config.isRead) {
							console.log('⏰ Restarting read timer for continued hover:', comment.username);
							this.startReadTimer(comment);
						}
					}
				} else {
					// Clear star hover state properly, but don't clear read timer if tooltip is still visible
					if (this.currentHoveredComment && !this.isHoveringTooltip) {
						console.log('⭐ Left star area, tooltip still visible - keeping read timer');
						this.currentHoveredComment = null;
						// Don't clear hoveredStar yet if tooltip is visible (needed for read timer)
						if (!this.tooltipVisible) {
							this.hoveredStar = null;
						}
						this.hideTooltipWithDelay();
					}
					
					// Always attempt to restore auto-rotation when not hovering anything
					if (!this.mouseDown && !this.isHoveringTooltip && !this.currentHoveredComment) {
						if (this.isHoveringCanvas && this.controlsEnabled) {
							this.setCursor('grab');
						}
						
						setTimeout(() => {
							if (!this.currentHoveredComment && !this.isHoveringTooltip && !this.mouseDown) {
								this.autoRotate = true;
								console.log('🔄 Auto-rotation resumed (no hover targets)');
							}
						}, 200);
					}
				}
			}

            createStarMapFromComments() {
                const comments = this.commentData.comments.filter(c => c.id !== 'no_comments');
                console.log('Creating stars for', comments.length, 'comments');

                if (comments.length === 0) {
                    this.createSingleStar();
                    return;
                }

                const maxLikesForScaling = 20; // The number of likes at which a star reaches its max size multiplier

                comments.forEach((comment, index) => {
                    const likes = comment.likes || 0;
                    const contentLength = comment.content ? comment.content.length : 0;

                    // Base size for every star is 1.0.
                    // The multiplier increases with likes, up to a max of 3x for a highly-liked comment.
                    const sizeMultiplier = 1 + Math.min(likes / maxLikesForScaling, 1) * 2.0;
                    const starSize = 0.4 * sizeMultiplier;

                    // Bluish-white color for all stars
					const starColor = new THREE.Color(0xE6F3FF);

                    // Intensity for brightness, not scaling
                    // Use a consistent value or give it a non-scaling variation.
                    const intensity = 1.0; 

                    // Positioning
                    const radiusMin = 2.5;
					const radiusMax = 5.5;
					const radius = radiusMin + Math.random() * (radiusMax - radiusMin);
					
					const baseTheta = (index / comments.length) * Math.PI * 2;
					const thetaVariation = (Math.random() - 0.5) * 0.8;
					const theta = baseTheta + thetaVariation;
					
					const minY = -0.5;
					const maxY = 3.0;
					const yPosition = minY + Math.random() * (maxY - minY);
					const biasedY = yPosition + Math.random() * 1.5;
					
					const x = radius * Math.cos(theta);
					const y = Math.min(maxY, biasedY);
					const z = radius * Math.sin(theta);

                    console.log(`Star ${index}: likes=${likes}, contentLength=${contentLength}, finalSize=${starSize.toFixed(2)}`);

                    const starGroup = this.createStarSystem({
                        size: starSize,
                        color: starColor,
                        intensity: intensity,
                        position: { x, y, z },
                        comment: comment,
                        delay: index * 0.05,
						originalSize: starSize,
						originalColor: starColor.getHex(),
						isRead: false
                    });

                    this.starSystems.push(starGroup);
                    this.scene.add(starGroup);
                });
            }

            createSingleStar() {
                const starGroup = this.createStarSystem({
                    size: 0.8,
                    color: 0xE6F3FF,
                    intensity: 1.0,
                    position: { x: 0, y: 0, z: 0 },
                    comment: { content: "No comments found", username: "System" },
                    delay: 0
                });
                
                this.starSystems.push(starGroup);
                this.scene.add(starGroup);
            }
            
            createStarSystem(config) {
				const starGroup = new THREE.Group();
				
				// Base geometry for the core star
				const starGeometry = new THREE.SphereGeometry(0.1, 32, 32); 
				const starMaterial = new THREE.MeshBasicMaterial({ 
					color: config.color,
					transparent: true,
					opacity: 0
				});
				
				const star = new THREE.Mesh(starGeometry, starMaterial);
				starGroup.add(star);
				
                // Glow effect geometry
				const glowGeometry = new THREE.SphereGeometry(0.3, 32, 32); 
				const glowMaterial = new THREE.ShaderMaterial({
					uniforms: {
						time: { value: 0 },
						color: { value: new THREE.Color(config.color) },
						intensity: { value: config.intensity } // Use intensity for shader effect
					},
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 color;
                        uniform float intensity;
                        varying vec3 vNormal;
                        
                        void main() {
                            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 3.0);
                            float pulse = sin(time * 2.0) * 0.15 + 0.85;
                            float alpha = fresnel * intensity * pulse;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                starGroup.add(glow);
                
                starGroup.position.set(config.position.x, config.position.y, config.position.z);
                
                // The star should start at size 0
				starGroup.scale.set(0, 0, 0); 
				starGroup.userData = { 
					originalScale: config.size,
					config: config,
					delay: config.delay
				};
                
                return starGroup;
            }
            
            createAtmosphericParticles() {
                const particleCount = 80;
                const particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const radius = 12 + Math.random() * 15;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    sizes[i] = Math.random() * 0.8 + 0.2;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const particleMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.4 }
                    },
                    vertexShader: `
                        attribute float size;
                        uniform float time;
                        
                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float opacity;
                        
                        void main() {
                            float dist = distance(gl_PointCoord, vec2(0.5));
                            if (dist > 0.5) discard;
                            
                            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                            float twinkle = sin(time * 3.0 + gl_FragCoord.x * 0.01) * 0.5 + 0.5;
                            gl_FragColor = vec4(0.7, 0.9, 1.0, alpha * opacity * twinkle);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.atmosphericParticles = new THREE.Points(particleGeometry, particleMaterial);
                this.scene.add(this.atmosphericParticles);
            }
            
            createBackgroundStars() {
                const backgroundStarCount = 500;
                const starGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(backgroundStarCount * 3);
                const colors = new Float32Array(backgroundStarCount * 3);
                const sizes = new Float32Array(backgroundStarCount);
                
                for (let i = 0; i < backgroundStarCount; i++) {
                    const radius = 25 + Math.random() * 80;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    const colorType = Math.random();
                    
                    if (colorType < 0.6) {
                        colors[i * 3] = 0.9 + Math.random() * 0.1;
                        colors[i * 3 + 1] = 0.95 + Math.random() * 0.05;
                        colors[i * 3 + 2] = 1.0;
                    } else if (colorType < 0.8) {
                        const intensity = 0.95 + Math.random() * 0.05;
                        colors[i * 3] = intensity;
                        colors[i * 3 + 1] = intensity;
                        colors[i * 3 + 2] = intensity;
                    } else {
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.9 + Math.random() * 0.1;
                        colors[i * 3 + 2] = 0.4 + Math.random() * 0.2;
                    }
                    
                    sizes[i] = Math.random() * 2.0 + 0.5;
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const backgroundStarMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.9 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform float time;
                        
                        void main() {
                            vColor = color;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            float twinkle = sin(time * 1.5 + position.x * 5.0 + position.y * 3.0) * 0.4 + 0.6;
                            gl_PointSize = size * twinkle * (400.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        uniform float opacity;
                        
                        void main() {
                            float dist = distance(gl_PointCoord, vec2(0.5));
                            if (dist > 0.5) discard;
                            
                            float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                            float center = 1.0 - smoothstep(0.0, 0.2, dist);
                            gl_FragColor = vec4(vColor * (1.0 + center), alpha * opacity);
                        }
                    `,
                    transparent: true,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending
                });
                
                this.backgroundStars = new THREE.Points(starGeometry, backgroundStarMaterial);
                this.scene.add(this.backgroundStars);
            }
            
            createStarConnections() {
                if (this.starSystems.length < 2) return;
                
                for (let i = 0; i < this.starSystems.length; i++) {
                    const star1 = this.starSystems[i];
                    const distances = [];
                    
                    for (let j = 0; j < this.starSystems.length; j++) {
                        if (i !== j) {
                            const star2 = this.starSystems[j];
                            const distance = star1.position.distanceTo(star2.position);
                            distances.push({ index: j, distance: distance, star: star2 });
                        }
                    }
                    
                    distances.sort((a, b) => a.distance - b.distance);
                    
                    const maxConnections = this.starSystems.length > 5 ? 3 : 2;
                    for (let k = 0; k < Math.min(maxConnections, distances.length); k++) {
                        if (distances[k].distance < 20) {
                            this.createConnection(star1.position, distances[k].star.position);
                        }
                    }
                }
            }
            
            createConnection(pos1, pos2) {
                const points = [pos1, pos2];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0 }
                    },
                    vertexShader: `
                        void main() {
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float opacity;
                        void main() {
                            float pulse = sin(time * 3.0) * 0.3 + 0.7;
                            gl_FragColor = vec4(0.5, 0.7, 1.0, opacity * pulse);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                const line = new THREE.Line(geometry, material);
                this.connections.push(line);
                this.scene.add(line);
            }
            
            // Interactive tooltip
			showTooltip(comment, worldPosition) {
				const screenPosition = worldPosition.clone().project(this.camera);
				const canvas = document.getElementById('hologram-canvas');
				const rect = canvas.getBoundingClientRect();
				
				const x = (screenPosition.x * 0.5 + 0.5) * rect.width + rect.left;
				const y = (screenPosition.y * -0.5 + 0.5) * rect.height + rect.top;
				
				// Always get fresh tooltip reference
				this.tooltip = document.getElementById('star-tooltip');
				const tooltip = this.tooltip;
				const avatar = document.getElementById('tooltip-avatar');
				const username = document.getElementById('tooltip-username');
				const content = document.getElementById('tooltip-content');
				const likes = document.getElementById('tooltip-likes');
				const date = document.getElementById('tooltip-date');
				
				username.textContent = comment.username || 'Unknown User';
				content.textContent = comment.content || 'No content';
				likes.textContent = `❤️ ${comment.likes || 0} likes`;
				date.textContent = `📅 ${formatDate(comment.createdAt)}`;
				
				if (comment.profileImage) {
					avatar.src = comment.profileImage;
					avatar.style.display = 'block';
				} else {
					avatar.style.display = 'none';
				}
				
				// Add or update save button
				let saveButton = tooltip.querySelector('.tooltip-save-button');
				if (!saveButton) {
					saveButton = document.createElement('button');
					saveButton.className = 'tooltip-save-button';
					tooltip.appendChild(saveButton);
				}
				
				const commentId = comment.id || `${comment.username}_${comment.content}_${comment.createdAt}` || comment.username;
				const isSaved = this.savedStars.has(commentId);
				saveButton.textContent = isSaved ? '⭐ Unsave Comment' : '💾 Save Comment';
				saveButton.className = `tooltip-save-button ${isSaved ? 'saved' : ''}`;
				
				// Button event handling with cloning prevents multiple listeners
				const newSaveButton = saveButton.cloneNode(true);
				saveButton.parentNode.replaceChild(newSaveButton, saveButton);

				newSaveButton.addEventListener('click', (e) => {
					e.preventDefault();
					e.stopPropagation();
					console.log('💾 Save button clicked for:', comment.username);
					
					this.toggleSaveComment(comment);
					
					const newSavedState = this.savedStars.has(commentId);
					newSaveButton.textContent = newSavedState ? '⭐ Unsave Comment' : '💾 Save Comment';
					newSaveButton.className = `tooltip-save-button ${newSavedState ? 'saved' : ''}`;
					
					// Don't break interaction flow after button click
					this.isHoveringButton = false;
					console.log('💾 Save action completed, states preserved');
				});

				newSaveButton.addEventListener('mouseenter', () => {
					this.isHoveringButton = true;
					console.log('🔘 Hovering save button');
				});

				newSaveButton.addEventListener('mouseleave', () => {
					this.isHoveringButton = false;
					console.log('🔘 Left save button');
				});
				
				// Position tooltip
				let tooltipX = x + 15;
				let tooltipY = y - 60;
				
				const estimatedWidth = Math.min(450, Math.max(200, (comment.content || '').length * 8 + 100));
				const estimatedHeight = 150;
				
				if (tooltipX + estimatedWidth > window.innerWidth - 20) {
					tooltipX = x - estimatedWidth - 15;
				}
				
				if (tooltipX < 20) {
					tooltipX = 20;
				}
				
				if (tooltipY < 20) {
					tooltipY = y + 20;
				} else if (tooltipY + estimatedHeight > window.innerHeight - 20) {
					tooltipY = window.innerHeight - estimatedHeight - 20;
				}
				
				tooltip.style.left = `${tooltipX}px`;
				tooltip.style.top = `${tooltipY}px`;
				
				// Set up proper tooltip interaction
				this.setupTooltipInteraction();
				
				// Show tooltip
				tooltip.classList.add('visible', 'interactive');
				this.tooltipVisible = true;

				console.log('Tooltip shown and interactive for:', comment.username);

				// Start read timer when tooltip becomes visible (but not for saved stars)
				this.startReadTimer(comment);
			}
			
			// Tooltip interaction with delayed hide/show
			setupTooltipInteraction() {
				// Ensure a fresh tooltip reference
				this.tooltip = document.getElementById('star-tooltip');
				if (this.boundTooltipEnter) {
					this.tooltip.removeEventListener('mouseenter', this.boundTooltipEnter);
					this.boundTooltipEnter = null;
				}
				if (this.boundTooltipLeave) {
					this.tooltip.removeEventListener('mouseleave', this.boundTooltipLeave);
					this.boundTooltipLeave = null;
				}
				
				this.boundTooltipEnter = () => {
					console.log('🎯 Mouse entered tooltip');
					this.isHoveringTooltip = true;
					this.autoRotate = false;
					this.clearTooltipTimeouts(false); // Don't clear read timer when entering tooltip
					this.setCursor('default');
					
					// Restart read timer if we have a hovered star and tooltip is visible
					if (this.hoveredStar && this.hoveredStar.userData.config?.comment) {
						const comment = this.hoveredStar.userData.config.comment;
						console.log('⏱️ Restarting read timer from tooltip hover for:', comment.username);
						this.startReadTimer(comment);
					}
				};
				
				this.boundTooltipLeave = () => {
					console.log('❌ Mouse left tooltip');
					this.isHoveringTooltip = false;
					this.hideTooltipWithDelay();
					
					// Clear hoveredStar
					if (!this.currentHoveredComment) {
						this.hoveredStar = null;
					}
					
					// Restore proper cursor and state
					if (this.isHoveringCanvas && this.controlsEnabled) {
						this.setCursor('grab');
					}
				};
				
				this.tooltip.addEventListener('mouseenter', this.boundTooltipEnter);
				this.tooltip.addEventListener('mouseleave', this.boundTooltipLeave);
				
				console.log('✅ Tooltip interaction handlers refreshed');
			}
			
			// Clear all tooltip-related timeouts
			clearTooltipTimeouts(includeReadTimer = true) {
				if (this.showTooltipTimeout) {
					clearTimeout(this.showTooltipTimeout);
					this.showTooltipTimeout = null;
				}
				if (this.hideTooltipTimeout) {
					clearTimeout(this.hideTooltipTimeout);
					this.hideTooltipTimeout = null;
				}
				if (includeReadTimer && this.readTimer) {
					clearTimeout(this.readTimer);
					this.readTimer = null;
					console.log('⏹️ Read timer cleared');
				}
			}

			// Show tooltip with delay
			showTooltipWithDelay(comment, worldPosition) {
				this.clearTooltipTimeouts();
				
				this.showTooltipTimeout = setTimeout(() => {
					if (comment === this.currentHoveredComment) {
						this.showTooltip(comment, worldPosition);
					}
				}, 100); // Short delay to prevent flicker
			}

			// Hide tooltip with delay
			hideTooltipWithDelay() {
				// Clear timeouts but NOT the read timer
				if (this.showTooltipTimeout) {
					clearTimeout(this.showTooltipTimeout);
					this.showTooltipTimeout = null;
				}
				if (this.hideTooltipTimeout) {
					clearTimeout(this.hideTooltipTimeout);
					this.hideTooltipTimeout = null;
				}
				
				this.hideTooltipTimeout = setTimeout(() => {
					if (!this.isHoveringTooltip) {
						this.hideTooltip();
					}
				}, 200);
			}

			// Immediate tooltip hide (for mouse down, etc.)
			hideTooltipImmediate() {
				this.clearTooltipTimeouts();
				this.hideTooltip();
			}
            
            hideTooltip() {
				const tooltip = this.tooltip;
				tooltip.classList.remove('visible', 'interactive');
				
				// Clear all timers including read timer
				this.clearTooltipTimeouts();
				
				// Complete state reset with proper recovery
				this.isHoveringTooltip = false;
				this.currentHoveredComment = null;
				this.hoveredStar = null;
				
				console.log('❌ Tooltip hidden - states reset');
				
				// Restore interaction capabilities
				if (this.controlsEnabled) {
					if (this.isHoveringCanvas) {
						this.setCursor('grab');
					} else {
						this.setCursor('default');
					}
					
					// Recovery attempts for auto-rotation
					const attemptRecovery = () => {
						if (!this.isHoveringTooltip && !this.currentHoveredComment && !this.mouseDown) {
							this.autoRotate = true;
							console.log('🔄 Auto-rotation force recovered');
							return true;
						}
						return false;
					};
					
					// Recovery at multiple intervals
					setTimeout(attemptRecovery, 100);
					setTimeout(attemptRecovery, 300);
					setTimeout(attemptRecovery, 600);
				}
			}
			
			// Start read timer for a comment
			startReadTimer(comment) {
				// Clear any existing read timer
				if (this.readTimer) {
					clearTimeout(this.readTimer);
					this.readTimer = null;
				}
				
				if (!this.hoveredStar || this.hoveredStar.userData.config.isRead) {
					return;
				}
				
				const commentId = comment.id || `${comment.username}_${comment.content}_${comment.createdAt}` || comment.username;
				const isSaved = this.savedStars.has(commentId);
				
				if (!isSaved) {
					console.log('⏱️ Starting read timer for:', comment.username);
					this.readTimer = setTimeout(() => {
						// Check if user is still interacting with this star or its tooltip
						const tooltip = document.getElementById('star-tooltip');
						const tooltipVisible = tooltip && tooltip.classList.contains('visible');
						const stillHoveringThisStar = this.hoveredStar && 
							this.hoveredStar.userData.config?.comment === comment;
						const stillInteracting = tooltipVisible || this.isHoveringTooltip || stillHoveringThisStar;
						
						// Check if star is still not saved before marking as read
						const stillNotSaved = !this.savedStars.has(commentId);
						
						if (stillNotSaved && this.hoveredStar && !this.hoveredStar.userData.config.isRead && stillInteracting) {
							console.log('📖 Marking as read after interaction timer:', comment.username);
							this.markStarAsRead(this.hoveredStar);
						} else {
							console.log('⏹️ Read timer expired but conditions not met - not marking as read');
						}
					}, 500);
				}
			}

			// Toggle save state for a comment
			toggleSaveComment(comment) {
				const commentId = comment.id || `${comment.username}_${comment.content}_${comment.createdAt}` || comment.username;
				
				// Clear read timer when saving/unsaving to prevent automatic read marking
				if (this.readTimer && this.hoveredStar && this.hoveredStar.userData.config?.comment) {
					const hoveredCommentId = this.hoveredStar.userData.config.comment.id || `${this.hoveredStar.userData.config.comment.username}_${this.hoveredStar.userData.config.comment.content}_${this.hoveredStar.userData.config.comment.createdAt}` || this.hoveredStar.userData.config.comment.username;
					if (hoveredCommentId === commentId) {
						clearTimeout(this.readTimer);
						this.readTimer = null;
						console.log('⏹️ Read timer cleared due to save/unsave action');
					}
				}
				
				if (this.savedStars.has(commentId)) {
					this.savedStars.delete(commentId);
					console.log('Unsaved comment:', comment.username);
				} else {
					this.savedStars.add(commentId);
					console.log('💫 Saved comment:', comment.username);
				}
				
				// Update appearance and force interaction recovery
				this.updateStarSavedAppearance(comment, this.savedStars.has(commentId));

				// Force restore interaction state
				setTimeout(() => {
					this.mouseDown = false;
					this.autoRotate = true;
					this.setCursor('grab');
					console.log('🔄 Forced interaction recovery after save');
				}, 100);
			}
			
			// Update star appearance based on saved state
			updateStarSavedAppearance(comment, isSaved) {
				const commentId = comment.id || `${comment.username}_${comment.content}_${comment.createdAt}` || comment.username;
				console.log('🔍 Looking for star with ID:', commentId);
				
				const starGroup = this.starSystems.find(star => {
					const starComment = star.userData.config?.comment;
					if (!starComment) return false;
					
					const starCommentId = starComment.id || `${starComment.username}_${starComment.content}_${starComment.createdAt}` || starComment.username;
					return starCommentId === commentId;
				});
				
				if (!starGroup) {
					console.log('❌ Could not find star for comment:', comment.content.substring(0, 20));
					return;
				}
				
				console.log('✅ Found star, current scale:', starGroup.scale.x, 'isSaved:', isSaved);
				
				// Change saved star size and color
				const starMesh = starGroup.children[0];
				if (isSaved) {
					console.log('⭐ Making star golden and larger:', comment.content.substring(0, 20));
					if (starMesh?.material) {
						starMesh.material.color.setHex(0xFFD700); // Golden
					}
					// Also update the main glow to golden
					const glowMesh = starGroup.children[1];
					if (glowMesh?.material?.uniforms) {
						glowMesh.material.uniforms.color.value = new THREE.Color(0xFFD700);
						glowMesh.material.uniforms.intensity.value = 2.0;
					}
					// Increased glow scale
					const originalScale = starGroup.userData.originalScale;
					const newScale = originalScale * 1.5;
					starGroup.scale.set(newScale, newScale, newScale);
					console.log('📏 Scale changed to saved size:', newScale);
					// Add golden glow effect
					this.addSavedStarGlow(starGroup);
				} else {
					console.log('🔄 Restoring original color and size:', comment.content.substring(0, 20));
					if (starMesh?.material) {
						const isRead = starGroup.userData.config.isRead;
						starMesh.material.color.setHex(isRead ? 0x808080 : 0xE6F3FF);
					}
					// Also restore the main glow color
					const glowMesh = starGroup.children[1];
					if (glowMesh?.material?.uniforms) {
						const isRead = starGroup.userData.config.isRead;
						glowMesh.material.uniforms.color.value = new THREE.Color(isRead ? 0x606060 : 0xE6F3FF);
						glowMesh.material.uniforms.intensity.value = isRead ? 0.2 : (starGroup.userData.config.intensity || 1.0);
					}
					// Reset to original likes-based scale or half if read
					const isRead = starGroup.userData.config.isRead;
					const originalScale = starGroup.userData.originalScale;
					const targetScale = isRead ? originalScale * 0.5 : originalScale;
					starGroup.scale.set(targetScale, targetScale, targetScale);
					console.log('📏 Scale reset to', targetScale);
					// Remove golden glow effect
					this.removeSavedStarGlow(starGroup);
				}
			}
			
			// Add golden glow effect for saved stars
			addSavedStarGlow(starGroup) {
				this.removeSavedStarGlow(starGroup);
				
				const starSize = starGroup.userData.config.size || 0.4;
				const glowGeometry = new THREE.SphereGeometry(starSize * 0.45, 16, 16);
				
				const glowMaterial = new THREE.ShaderMaterial({
					uniforms: {
						time: { value: 0 },
						color: { value: new THREE.Color(0xFFD700) },
						intensity: { value: 1.5 }
					},
					vertexShader: `
						varying vec3 vNormal;
						varying vec3 vPosition;
						void main() {
							vNormal = normalize(normalMatrix * normal);
							vPosition = position;
							gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
						}
					`,
					fragmentShader: `
						uniform float time;
						uniform vec3 color;
						uniform float intensity;
						varying vec3 vNormal;
						varying vec3 vPosition;
						
						void main() {
							float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.0);
							float pulse = sin(time * 2.0 + length(vPosition) * 3.0) * 0.3 + 0.7;
							float alpha = fresnel * pulse * intensity * 0.8;
							gl_FragColor = vec4(color, alpha);
						}
					`,
					transparent: true,
					blending: THREE.AdditiveBlending,
					side: THREE.BackSide
				});
				
				const savedGlow = new THREE.Mesh(glowGeometry, glowMaterial);
				savedGlow.userData.isSavedGlow = true;
				starGroup.add(savedGlow);
				
				console.log('🌟 Added golden glow to saved star');
			}
			
			// Remove golden glow effect
			removeSavedStarGlow(starGroup) {
				const savedGlow = starGroup.children.find(child => child.userData.isSavedGlow);
				if (savedGlow) {
					starGroup.remove(savedGlow);
					if (savedGlow.geometry) savedGlow.geometry.dispose();
					if (savedGlow.material) savedGlow.material.dispose();
					console.log('🗑️ Removed golden glow from star');
				}
			}
            
			// Mark star as read
			markStarAsRead(starGroup) {
				if (!starGroup || starGroup.userData.config.isRead) return;
				
				console.log('📖 Marking star as read:', starGroup.userData.config.comment.username);
				
				starGroup.userData.config.isRead = true;
				
				const starMesh = starGroup.children[0];
				const glowMesh = starGroup.children[1];
				
				// Don't gray out saved stars
				const commentId = starGroup.userData.config.comment.id || starGroup.userData.config.comment.username;
				const isSaved = this.savedStars.has(commentId);

				if (starMesh && starMesh.material && !isSaved) {
					starMesh.material.color.setHex(0x808080);
				}

				// Don't dim glow for saved stars
				if (glowMesh && glowMesh.material && !isSaved) {
					if (glowMesh.material.uniforms && glowMesh.material.uniforms.intensity) {
						glowMesh.material.uniforms.intensity.value = 0.2;
					}
					if (glowMesh.material.uniforms && glowMesh.material.uniforms.color) {
						glowMesh.material.uniforms.color.value = new THREE.Color(0x606060);
					}
				}
				
				// Don't shrink saved stars, only read ones
				if (!isSaved) {
					const currentScale = starGroup.scale.x;
					// Calculate target scale as 50% of the original likes-based scale
					const originalScale = starGroup.userData.originalScale;
					const targetScale = originalScale * 0.5;
					
					const startScale = currentScale;
					const startTime = Date.now();
					const duration = 500;
					
					const animateScale = () => {
						const elapsed = Date.now() - startTime;
						const progress = Math.min(elapsed / duration, 1);
						const easeProgress = 1 - Math.pow(1 - progress, 3);
						
						const newScale = startScale + (targetScale - startScale) * easeProgress;
						starGroup.scale.set(newScale, newScale, newScale);
						
						if (progress < 1) {
							requestAnimationFrame(animateScale);
						}
					};
					
					animateScale();
				}
			}

            startHologramSequence() {
                this.showLoadingOverlay();
                this.updateLoadingProgress(10, "Initializing holographic projector...");
                
                const flashOverlay = document.getElementById('flash-overlay');

				setTimeout(() => {
					this.updateLoadingProgress(25, "Powering up holographic projector...");
					const projectorBeam = document.querySelector('.projector-beam');
					if (projectorBeam) {
						projectorBeam.style.animation = 'beam-activation 3s ease-in-out forwards, beam-pulse 3s ease-in-out infinite';
					}
				}, 500);
                
                setTimeout(() => {
                    this.updateLoadingProgress(40, "Calibrating stellar coordinates...");
                }, 1800);
                
                setTimeout(() => {
                    this.updateLoadingProgress(55, "Materializing comment constellation...");
                    flashOverlay.classList.add('active');
                }, 2500);
                
                setTimeout(() => {
                    this.updateLoadingProgress(75, "Finalizing galaxy projection...");
                    this.animateStarMap();
                }, 3000);
            }
            
            // Animation loop with auto-rotation
			animateStarMap() {
				this.isAnimating = true;
				const startTime = Date.now();
				
				const animate = () => {
					const elapsed = (Date.now() - startTime) / 1000;
					
					// Star burst expansion (0-4s)
					if (elapsed < 4) {
						const progress = elapsed / 4;
						const easeProgress = 1 - Math.pow(1 - progress, 3);
						
						this.starSystems.forEach((starGroup) => {
							const delay = starGroup.userData.delay;
							const adjustedProgress = Math.max(0, (progress - delay / 4) * 1.2);
							
							if (adjustedProgress > 0) {
								const scale = Math.min(adjustedProgress, 1);
								const commentId = starGroup.userData.config?.comment?.id || starGroup.userData.config?.comment?.username;
								const isSaved = this.savedStars.has(commentId);
								let finalScale = scale * starGroup.userData.originalScale;
								
								if (isSaved) {
									finalScale = scale * starGroup.userData.originalScale * 1.5;
								}
								
								starGroup.scale.set(finalScale, finalScale, finalScale);
								
								starGroup.children.forEach(child => {
									if (child.material) {
										if (child.material.opacity !== undefined) {
											child.material.opacity = Math.min(adjustedProgress, 1);
										}
										if (child.material.uniforms && child.material.uniforms.time) {
											child.material.uniforms.time.value = elapsed;
										}
									}
								});
							}
						});
						
						this.connections.forEach(connection => {
							connection.material.uniforms.opacity.value = easeProgress * 0.6;
							connection.material.uniforms.time.value = elapsed;
						});
					}
					
					// Enable interactive mode (4s+)
					else {
						if (!this.controlsEnabled) {
							this.controlsEnabled = true;
							const canvas = document.getElementById('hologram-canvas');
							canvas.style.cursor = 'grab';
							console.log('Controls enabled - drag to rotate');
							
							this.updateLoadingProgress(90, "Systems online - preparing interface...");
							setTimeout(() => {
								this.updateLoadingProgress(100, "Galaxy ready for exploration!");
								
								setTimeout(() => {
									this.playRandomSoundEffect();
								}, 200);
								
								setTimeout(() => {
									this.hideLoadingOverlay();
									this.isLoading = false;
									
									// Ensure auto-rotation starts
									this.autoRotate = true;
									console.log('🔄 Auto-rotation ENABLED after loading complete');
								}, 800);
							}, 500);
						}
						
						// Proper rotation handling
						if (this.mouseDown) {
							// Apply manual rotation
							this.scene.rotation.x = this.rotationX;
							this.scene.rotation.y = this.rotationY;
						} else if (this.autoRotate && !this.currentHoveredComment && !this.isHoveringTooltip) {
							// Auto-rotate from current position
							this.scene.rotation.y += 0.0001;
							this.rotationY = this.scene.rotation.y;
							
							// Prevent overflow
							if (this.rotationY > Math.PI * 2) {
								this.rotationY -= Math.PI * 2;
								this.scene.rotation.y = this.rotationY;
							}
						} else if (!this.autoRotate && (this.rotationX !== 0 || this.rotationY !== 0)) {
							// Apply stored manual rotation when not auto-rotating
							this.scene.rotation.x = this.rotationX;
							this.scene.rotation.y = this.rotationY;
						}
						
						// Update camera zoom
						if (this.zoomLevel !== 1.0) {
							const baseDistance = 8;
							const newDistance = baseDistance / this.zoomLevel;
							
							const direction = new THREE.Vector3(0, 0, 1);
							direction.applyQuaternion(this.camera.quaternion);
							direction.multiplyScalar(newDistance);
							
							this.camera.position.copy(direction);
						}
						
						// Update effects
						this.starSystems.forEach(starGroup => {
							starGroup.children.forEach(child => {
								if (child.material && child.material.uniforms && child.material.uniforms.time) {
									child.material.uniforms.time.value = elapsed;
								}
							});
						});
						
						this.connections.forEach(connection => {
							connection.material.uniforms.time.value = elapsed;
						});
						
						if (this.atmosphericParticles && this.atmosphericParticles.material.uniforms) {
							this.atmosphericParticles.material.uniforms.time.value = elapsed;
						}
						
						if (this.backgroundStars && this.backgroundStars.material.uniforms) {
							this.backgroundStars.material.uniforms.time.value = elapsed;
						}
					}
					
					this.renderer.render(this.scene, this.camera);
					
					if (this.isAnimating) {
						this.animationFrame = requestAnimationFrame(animate);
					}
				};
				
				animate();
			}
            
            dispose() {
                this.isAnimating = false;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                
                this.hideTooltip();
                
                // Clean up tooltip event listeners
				const tooltip = this.tooltip;
				if (tooltip && this.boundTooltipEnter && this.boundTooltipLeave) {
					tooltip.removeEventListener('mouseenter', this.boundTooltipEnter);
					tooltip.removeEventListener('mouseleave', this.boundTooltipLeave);
				}
				// Clear bound methods
				this.boundTooltipEnter = null;
				this.boundTooltipLeave = null;
				// Reset tooltip state
				if (tooltip) {
					tooltip.classList.remove('visible', 'interactive');
					// Force remove any save buttons that might be lingering
					const saveButtons = tooltip.querySelectorAll('.tooltip-save-button');
					saveButtons.forEach(button => button.remove());
				}
				// Reset all tooltip-related properties
				this.tooltip = null;
				this.tooltipVisible = false;
				this.isHoveringTooltip = false;
				this.currentHoveredComment = null;
				this.hoveredStar = null;
                
                // Complete state reset
				this.scene.rotation.set(0, 0, 0);
				this.controlsEnabled = false;
				this.mouseDown = false;
				this.rotationX = 0;
				this.rotationY = 0;
				this.autoRotate = true;
				this.isHoveringCanvas = false;
				this.isHoveringTooltip = false;
				this.isHoveringButton = false;
				this.currentHoveredComment = null;
				this.hoveredStar = null;
				this.zoomLevel = 1.0;
				this.clearTooltipTimeouts();
                
                // Complete cleanup
                this.starSystems.forEach(starGroup => {
                    this.scene.remove(starGroup);
                    starGroup.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (child.material.dispose) child.material.dispose();
                            if (child.material.uniforms) {
                                Object.values(child.material.uniforms).forEach(uniform => {
                                    if (uniform.value && uniform.value.dispose) {
                                        uniform.value.dispose();
                                    }
                                });
                            }
                        }
                    });
                });
                this.starSystems = [];
                
                this.connections.forEach(connection => {
                    this.scene.remove(connection);
                    if (connection.geometry) connection.geometry.dispose();
                    if (connection.material) connection.material.dispose();
                });
                this.connections = [];
                
                if (this.atmosphericParticles) {
                    this.scene.remove(this.atmosphericParticles);
                    if (this.atmosphericParticles.geometry) this.atmosphericParticles.geometry.dispose();
                    if (this.atmosphericParticles.material) this.atmosphericParticles.material.dispose();
                    this.atmosphericParticles = null;
                }
                
                if (this.backgroundStars) {
                    this.scene.remove(this.backgroundStars);
                    if (this.backgroundStars.geometry) this.backgroundStars.geometry.dispose();
                    if (this.backgroundStars.material) this.backgroundStars.material.dispose();
                    this.backgroundStars = null;
                }
                
                while(this.scene.children.length > 0) {
                    this.scene.remove(this.scene.children[0]);
                }
                
                if (this.renderer) {
                    this.renderer.dispose();
                }
				
				// Force cursor reset
				this.setCursor('default');
            }
        }

        // Main application functions
        window.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Handle session from OAuth callback
            if (urlParams.get('session')) {
                sessionId = urlParams.get('session');
                localStorage.setItem('session-id', sessionId);
                console.log('Session ID received from OAuth:', sessionId);
            }
            
            if (urlParams.get('authenticated') === 'true') {
                setAuthenticatedState(true);
                showStatus('✅ Successfully connected to Patreon!', 'success');
            } else if (urlParams.get('error')) {
                const error = urlParams.get('error');
                showStatus(`❌ Error: ${error}`, 'error');
            }
            
            checkAuthStatus();
        });

        // Session management
        let sessionId = localStorage.getItem('session-id');
        if (!sessionId) {
            sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('session-id', sessionId);
        }

        function getSessionHeaders() {
            return {
                'x-session-id': sessionId,
                'Content-Type': 'application/json'
            };
        }

        async function checkAuthStatus() {
            try {
                const response = await fetch('/api/health', {
                    headers: { 'x-session-id': sessionId }
                });
                const data = await response.json();
                if (data.authenticated) {
                    setAuthenticatedState(true);
                }
            } catch (error) {
                console.log('Could not check auth status:', error);
            }
        }

        function connectPatreon() {
            console.log('connectPatreon function called!');
            showStatus('Redirecting to Patreon...', 'loading');
            window.location.href = `/auth/patreon?session=${sessionId}`;
        }

        async function setAuthenticatedState(authenticated) {
            isAuthenticated = authenticated;
            const authSection = document.getElementById('auth-section');
            const extractSection = document.getElementById('extract-section');
            const authStatus = document.getElementById('auth-status');
            const connectButton = authSection.querySelector('button');

            if (authenticated) {
                try {
                    const response = await fetch('/api/user-info', {
                        headers: { 'x-session-id': sessionId }
                    });
                    if (response.ok) {
                        const userData = await response.json();
                        authStatus.textContent = `✅ Authenticated with Patreon (${userData.username})`;
                    } else {
                        authStatus.textContent = '✅ Authenticated with Patreon';
                    }
                } catch (error) {
                    authStatus.textContent = '✅ Authenticated with Patreon';
                }
                
                authStatus.style.color = '#28a745';
                extractSection.style.display = 'block';
                connectButton.textContent = 'Re-authenticate';
            } else {
                authStatus.textContent = '🔐 Not Authenticated';
                authStatus.style.color = '#dc3545';
                extractSection.style.display = 'none';
                connectButton.textContent = 'Connect to Patreon';
            }
        }

        async function extractComments() {
            if (!isAuthenticated) {
                showStatus('Please connect with Patreon first', 'error');
                return;
            }

            const postUrl = document.getElementById('postUrl').value.trim();
            if (!postUrl) {
                showStatus('Please enter a post URL', 'error');
                return;
            }

            showStatus('Extracting comments...', 'loading');
            
            const resultsDiv = document.getElementById('results');
            resultsDiv.style.display = 'none';
            extractedData = null;

            try {
                const response = await fetch('/api/extract-post', {
                    method: 'POST',
                    headers: getSessionHeaders(),
                    body: JSON.stringify({ postUrl })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to extract data');
                }

                extractedData = data;
                displayResults(data);
                showStarMap();
                
                showStatus(`✅ Found ${data.comments.length} comments! Displaying holographic galaxy...`, 'success');

            } catch (error) {
                console.error('Error:', error);
                const resultsDiv = document.getElementById('results');
                resultsDiv.style.display = 'none';
                extractedData = null;
                showStatus(`❌ Error: ${error.message}`, 'error');
            }
        }

        function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('results-content');

            let html = `
                <p><strong>Post:</strong> ${data.post.title}</p>
                <p><strong>Post Comments:</strong> ${data.comments.length}<small> (Excludes replies)</small></p>
                <p><strong>Post Likes:</strong> ${data.totalLikes}</p>
                <button onclick="exportData()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px; margin: 15px 0;">Export comments to JSON</button>
                <hr>
            `;

            if (data.comments.length > 0) {
                data.comments.forEach(comment => {
                    const profileImage = comment.profileImage ? 
                        `<img src="${comment.profileImage}" alt="${comment.username}" class="profile-image">` : 
                        '<span style="font-size: 24px; margin-right: 10px;">👤</span>';
                    
                    html += `
                        <div class="comment">
                            <div class="comment-author">
                                ${profileImage}
                                <strong>${comment.username}</strong>
                            </div>
                            <p>${comment.content}</p>
                            <div class="comment-meta">
                                ❤️ ${comment.likes} likes • 📅 ${formatDate(comment.createdAt)}
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<p>No comments found.</p>';
            }

            contentDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }

        function showStarMap() {
            if (!extractedData) {
                showStatus('No comment data available', 'error');
                return;
            }

            const container = document.getElementById('star-map-container');
            
            // Clear any existing holograms
            if (starMapHologram) {
                console.log('Disposing previous hologram...');
                starMapHologram.dispose();
                starMapHologram = null;
                
                // Clear the canvas
                const canvas = document.getElementById('hologram-canvas');
                if (canvas) {
                    const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (context) {
                        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
                    }
                }
                
                // Reset visual elements
				const flashOverlay = document.getElementById('flash-overlay');
				flashOverlay.classList.remove('active');
            }
            
            document.getElementById('post-title').textContent = extractedData.post.title;
            
            const commentCount = extractedData.comments.filter(c => c.id !== 'no_comments').length;
            document.getElementById('comment-count').textContent = `${commentCount} ${commentCount === 1 ? 'comment' : 'comments'}`;
            
            const totalLikes = extractedData.totalLikes || 0;
            document.getElementById('total-likes').textContent = `${totalLikes} ${totalLikes === 1 ? 'like' : 'likes'}`;
            
            container.classList.add('active');
            
            // Reset tooltip before creating new hologram
			const tooltip = document.getElementById('star-tooltip');
			if (tooltip) {
				tooltip.classList.remove('visible', 'interactive');
				tooltip.style.display = 'none';
				// Remove any lingering save buttons
				const saveButtons = tooltip.querySelectorAll('.tooltip-save-button');
				saveButtons.forEach(button => button.remove());
				// Force reset
				setTimeout(() => {
					tooltip.style.display = 'block';
				}, 50);
			}

			// Create new hologram with delay
			setTimeout(() => {
				starMapHologram = new StarMapHologram(extractedData);
				starMapHologram.startHologramSequence();
				startGalaxyAudio();
			}, 150);
        }

        function startGalaxyAudio() {
            console.log('Attempting to start galaxy audio...');
            
            if (!galaxyAudio) {
                galaxyAudio = document.getElementById('galaxy-audio');
            }
            
            if (galaxyAudio) {
                galaxyAudio.volume = 0.3;
                
                const playPromise = galaxyAudio.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('Audio started successfully');
                        isAudioMuted = false;
                        updateAudioButtonStates(false);
                    }).catch(error => {
                        console.log('Audio autoplay blocked by browser.', error);
                        isAudioMuted = true;
                        updateAudioButtonStates(true);
                    });
                } else {
                    updateAudioButtonStates(true);
                }
            }
        }
        
        function updateAudioButtonStates(muted) {
            const audioButton = document.getElementById('audio-toggle');
            const audioButtonInfo = document.getElementById('audio-toggle-info');
            
            if (muted) {
                if (audioButton) {
                    audioButton.textContent = '🔇';
                    audioButton.classList.add('muted');
                    audioButton.title = 'Unmute Audio';
                }
                if (audioButtonInfo) {
                    audioButtonInfo.textContent = '🔇';
                    audioButtonInfo.classList.add('muted');
                    audioButtonInfo.title = 'Unmute Audio';
                }
            } else {
                if (audioButton) {
                    audioButton.textContent = '🔊';
                    audioButton.classList.remove('muted');
                    audioButton.title = 'Mute Audio';
                }
                if (audioButtonInfo) {
                    audioButtonInfo.textContent = '🔊';
                    audioButtonInfo.classList.remove('muted');
                    audioButtonInfo.title = 'Mute Audio';
                }
            }
        }

        function stopGalaxyAudio() {
            if (galaxyAudio) {
                galaxyAudio.pause();
                galaxyAudio.currentTime = 0;
            }
        }

        function toggleAudio() {
            if (!galaxyAudio) {
                galaxyAudio = document.getElementById('galaxy-audio');
            }
            
            if (isAudioMuted || (galaxyAudio && galaxyAudio.paused)) {
                // Unmute/play
                isAudioMuted = false;
                updateAudioButtonStates(false);
                
                if (galaxyAudio) {
                    galaxyAudio.volume = 0.3;
                    galaxyAudio.play().catch(error => {
                        console.log('Audio play failed:', error);
                        updateAudioButtonStates(true);
                    });
                }
            } else {
                // Mute/pause
                isAudioMuted = true;
                updateAudioButtonStates(true);
                
                if (galaxyAudio) {
                    galaxyAudio.pause();
                }
            }
        }

        // closeStarMap function without tooltip manipulation
        function closeStarMap() {
			const container = document.getElementById('star-map-container');
			const flashOverlay = document.getElementById('flash-overlay');
			const loadingOverlay = document.getElementById('loading-overlay');
			const projectorBeam = document.querySelector('.projector-beam');
			
			container.classList.remove('active');
			flashOverlay.classList.remove('active');
			loadingOverlay.classList.remove('active');
			
			// Reset projector beam animation
			if (projectorBeam) {
				projectorBeam.style.animation = 'beam-pulse 3s ease-in-out infinite';
			}
			
			stopGalaxyAudio();
			
			if (starMapHologram) {
				starMapHologram.dispose();
				starMapHologram = null;
			}
			
			// Clear canvas
			const canvas = document.getElementById('hologram-canvas');
			if (canvas) {
				const context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
				if (context) {
					context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
				}
			}
		}

        function exportData() {
			if (!extractedData) return;

			// Create filename based on post title
			let filename = 'patreon_comments';
			
			if (extractedData.post && extractedData.post.title) {
				// Get the post title and clean it up
				let postTitle = extractedData.post.title
					.trim()                          // Remove leading/trailing whitespace
					.replace(/[^\w\s-]/g, '')        // Remove special characters except letters, numbers, spaces, and hyphens
					.replace(/\s+/g, '_')            // Replace spaces with underscores
					.replace(/_+/g, '_')             // Replace multiple underscores with single underscore
					.replace(/^_|_$/g, '');          // Remove leading/trailing underscores
				
				// If we successfully cleaned the title, use it
				if (postTitle) {
					filename = postTitle;
				}
			}
			
			// Add date in YYYYMMDD format
			const today = new Date();
			const dateStr = today.getFullYear() + 
						   String(today.getMonth() + 1).padStart(2, '0') + 
						   String(today.getDate()).padStart(2, '0');
			
			const finalFilename = `${filename}_${dateStr}.json`;

			const dataStr = JSON.stringify(extractedData, null, 2);
			const dataBlob = new Blob([dataStr], { type: 'application/json' });
			const url = URL.createObjectURL(dataBlob);

			const link = document.createElement('a');
			link.href = url;
			link.download = finalFilename;
			link.click();

			URL.revokeObjectURL(url);
			showStatus('✅ Data exported!', 'success');
		}

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => status.style.display = 'none', 5000);
            }
        }

        function formatDate(dateString) {
            if (!dateString || dateString === 'Unknown') return 'Unknown';
            return new Date(dateString).toLocaleString();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (starMapHologram && starMapHologram.camera && starMapHologram.renderer) {
                starMapHologram.camera.aspect = window.innerWidth / window.innerHeight;
                starMapHologram.camera.updateProjectionMatrix();
                starMapHologram.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Handle escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeStarMap();
            }
        });

    </script>
</body>
</html>